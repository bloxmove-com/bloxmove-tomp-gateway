/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
// @ts-nocheck

export interface paths {
  '/plannings': {
    /** Returns plannings for the given travel plan. <p>Start time can be defined, but is optional. If startTime is not provided, but required by the third party API, a default value of "Date.now()" is used. [from MaaS-API /listing]. During the routing phase this service can be used to check availability without any state changes. <p>In the final check, just before presenting the alternatives to the user, a call should be made using `booking-intent`, requesting the TO to provide booking IDs to reference to during communication with the MP. <p>see (2.1) in the process flow - planning */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** Specifies whether IDs should be returned for the leg options that can be referred to when booking */
          'booking-intent'?: boolean;
        };
      };
      responses: {
        /** Available transport methods matching the given query parameters. If no transport methods are available, an empty array is returned. */
        201: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['planning'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['planningRequest'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/bookings': {
    /** Optional - Returns bookings that has been created earlier, selected on state. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          state: components['schemas']['bookingState'];
        };
      };
      responses: {
        /** The bookings matching the query */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['booking']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    /** Creates a new `Booking` for the TO in **Pending** state. The ID of the posted booking should be the ID provided in the previous step (planning). <p>The Booking may be modified in the response, e.g. location being adjusted for a more suitable pick-up location. In addition, the service may contain a **meta** attribute for arbitrary TO metadata that the TO needs later, and **token** attribute depicting how long the current state is valid. <p> see (3.2) in the process flow - booking. <p>The MP can implement this endpoint when it allows direct booking by TOs. The specific TO can book an asset from themselves to get it registrated and handled (financially) by the MP. */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
      };
      responses: {
        /** A new booking was succesfully created, status pending */
        201: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
            /** The result is valid until this timestamp. The pending booking is expired after this timestamp. */
            Expires: string;
          };
          content: {
            'application/json': components['schemas']['booking'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        409: components['responses']['409Conflict'];
        410: components['responses']['410Gone'];
      };
      /** One of available booking options, returned by /plannings, with an ID. */
      requestBody: {
        content: {
          'application/json': components['schemas']['bookingRequest'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/bookings/{id}/events': {
    /** This endpoint **must** be used to alter the state of a booking:<br>- The operation 'CANCEL' Cancels the booking (see <4> in the process flow - booking), <br>- the operation 'EXPIRE' informs that the booking-option is expired (see <5> in the process flow - booking) and <br>- the 'COMMIT' actually makes this booking option a real confirmed booking. (see also (3.2) in process flow - booking). This event should also be used to commit in the 'postponed-commit' scenario.<br> - 'DENY' tells the MP that the leg is cancelled in the post-commit scenario. <p> `CANCEL` - Cancels a confirmed booking. Cancelling twice should still return 204. <br> `EXPIRE` - Typically for sending back a signal from TO to MP to tell the pending state is expired. Expiring twice should return 204. Expiring a booking in a non-pending state will result in 403. <BR> `COMMIT` - Turns the booking in a confirmed state, after all legs are in state pending. Committing twice will result in 204. If the booking is in state CANCELLED or EXPIRED, a commit will result a 403. <BR> `DENY` - Used for the 'postponed-commit' scenario. Whenever a TO cannot give guarantees directly to fulfil a booking, it can return a 'COMMIT', but the state of the booking object should be 'POSTPONED-COMMIT'. In the conditions returned in the planning phase is stated until when this phase can be. After this time it will become expired. Otherwise, it can be committed when the leg is confirmed or denied (using this event). */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        /** The modified booking */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['booking'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['bookingOperation'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/bookings/{id}': {
    /** Returns the booking. See (3.5.2) in the process flow - booking. In the 'meta'-field the digital tickes can be returned (see (3.3) in the process flow - booking) */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        /** The booking was found */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['booking'];
          };
        };
        401: components['responses']['401Unauthorized'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
      };
    };
    /** Optional - This endpoint should be used to adjust the parameters of the booking. Changes not acceptable to the TO should return 400. If a booking is started and can no longer be adjusted the TO should return 403. The state of the booking should **never** be adjusted using this method. Use /bookings/{id}/events for that. See also (7.2) in the flow diagram - booking. */
    put: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        /** The booking was modified */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['booking'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        409: components['responses']['409Conflict'];
        410: components['responses']['410Gone'];
      };
      /** changed booking */
      requestBody: {
        content: {
          'application/json': components['schemas']['booking'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Booking identifier */
        id: string;
      };
    };
  };
  '/bookings/{id}/subscription': {
    /** Optional - subscribe to a specific booking (=leg & (type of) asset). This is an optional endpoint. This endpoint facilitates notifications in all the phases. (see (7.1) in the flow chart - execution) */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
      };
    };
    /** Optional - subscribe to a specific booking (=leg & (type of) asset). This is an optional endpoint */
    delete: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
        /** Unexpected error */
        default: {
          content: {
            'application/json': components['schemas']['error'];
          };
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Booking identifier */
        id: string;
      };
    };
  };
  '/bookings/{id}/notifications': {
    /** retrieves all notifications concerning events related to this booking. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        /** The bookings matching the query */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['notification']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
      };
    };
    /** notification between MaaS provider and Transport operator in case of user no-show or if specific asset is not available or some other event occurs not covered by other API calls. */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        410: components['responses']['410Gone'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['notification'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Booking identifier */
        id: string;
      };
    };
  };
  '/legs/{id}/available-assets': {
    /** Returns a list of available assets for the given leg. These assets can be used to POST to /legs/{id}/asset if no specific asset is assigned by the TO. If picking an asset is not allowed for this booking, or one already has been, 403 should be returned. If the booking is unknown, 404 should be returned. See (4.7) in the process flow. - trip execution */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
        query: {
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
        };
      };
      responses: {
        /** Available assets for the leg. If no suitable assets are found an empty array is to be returned. */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['asset']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/legs/{id}': {
    /** Retrieves the latest summary of the leg, being the execution of a portion of a journey travelled using one asset (vehicle). Every leg belongs to one booking, every booking has at least one leg. Where the booking describes the agreement between user/MP and TO, the leg describes the journey as it occured. See (4.3) in the flow chart - trip execution */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        /** operation successful */
        200: {
          content: {
            'application/json': components['schemas']['leg'];
          };
        };
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
    };
    /** Updates the leg with new information. Only used for updates about execution to the MP. To request changes as the MP, the booking should be updated and the TO can accept the change and update the leg in turn. */
    put: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
      /** changed leg (e.g. with different duration or destination) */
      requestBody: {
        content: {
          'application/json': components['schemas']['leg'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/legs/{id}/events': {
    /** This endpoint must be used to alter the state of a leg.<br> Operations:<br> `PREPARE` the TO can send a message telling the MP that he is preparing the booked leg [To be implemented by the MP] (see (7.2) in the process flow - trip execution),<br> `ASSIGN_ASSET` can assign an asset to a leg. Can be to assign an asset in case there is still an asset type assigned [Optionally implementable by the MP]. See (4.7) in the process flow - trip execution<br> `SET_IN_USE` will activate the leg or resume the leg [TO and MP] (see (4.6) in process flow),<br> `TIME_EXTEND` will be used to request an extension in time; the end user wants to use the asset longer, the `time` field contains the new end time,<br> `TIME_POSTPONE` will be used to request a delay in the departure time, the end user wants to depart later, the `time` field contains the new departure time,<br> `PAUSE` will pause the leg [TO and MP] (see (4.6) in process flow),<br> `START_FINISHING` will start the end-of-leg [Optionally implementable by TO and MP],<br> `FINISH` will end this leg (see (4.6) in process flow) [TO and MP] */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        /** operation successful */
        200: {
          content: {
            'application/json': components['schemas']['leg'];
          };
        };
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
        /** In case of temporary malfunctioning, this response can be send (e.g. bluetooth lock jammed). See also https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After */
        503: unknown;
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['legEvent'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/legs/{id}/progress': {
    /** Monitors the current location of the asset and duration & distance of the leg (see (4.7) in process flow) */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
        query: {
          /** Specifies if only the location should be returned */
          'location-only'?: boolean;
        };
      };
      responses: {
        /** operation successful */
        200: {
          content: {
            'application/json': components['schemas']['legProgress'];
          };
        };
        401: components['responses']['401Unauthorized'];
        404: components['responses']['404NotFound'];
      };
    };
    /** Monitors the current location of the asset and duration & distance of the leg */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        204: components['responses']['204NoContent'];
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['legProgress'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/operator/ping': {
    /** This is a healthcheck endpoint to see if the TO is up and running perfectly. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
        };
      };
      responses: {
        /** successful operation */
        200: unknown;
        401: components['responses']['401Unauthorized'];
        /** not every endpoint functions properly */
        500: unknown;
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
      };
    };
  };
  '/legs/{id}/confirmation': {
    /** The TO can request confirmation for certain actions from the MP. */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
        };
        path: {
          /** Leg identifier */
          id: string;
        };
      };
      responses: {
        /** operation successful */
        200: {
          content: {
            'application/json': boolean;
          };
        };
        401: components['responses']['401Unauthorized'];
        404: components['responses']['404NotFound'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['confirmationRequest'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
      };
      path: {
        /** Leg identifier */
        id: string;
      };
    };
  };
  '/operator/meta': {
    /** all versions that are implemented on this url, are described in the result of this endpoint. In contains all versions and per version the endpoints, their status and the supported scenarios. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
      };
      responses: {
        /** successful operation */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['endpointImplementation']>;
          };
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/stations': {
    /** All stations contained in this list are considered public (ie, can be shown on a map for public use). If there are private stations (such as Capital Bikeshare's White House station) these should not be exposed here and their status should not be included [from GBFS]. This endpoint can be filtered using the regionId OR with the combination lon, lat and range. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** the longitude of the search location (WGS84) */
          lon?: number;
          /** the latitude of the search location (WGS84) */
          lat?: number;
          /** the range in meters from the search location to look for stations */
          radius?: number;
        };
      };
      responses: {
        /** successful operation */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['stationInformation']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/available-assets': {
    /** Returns a list of available assets. */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** optional id of the station to use in the filter (/operator/stations) */
          stationId?: string;
        };
      };
      responses: {
        /** Available assets or asset-types. In case assets are replied, the realtime location is also available. */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['assetType']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/alerts': {
    /** This feed is intended to inform customers about changes to the system that do not fall within the normal system operations. For example, system closures due to weather would be listed here, but a system that only operated for part of the year would have that schedule listed in the system-calendar.json feed. This file is an array of alert objects defined as below. Obsolete alerts should be removed so the client application can safely present to the end user everything present in the feed. The consumer could use the start/end information to determine if this is a past, ongoing or future alert and adjust the presentation accordingly. [from GBFS] */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** optional id of the station to use in the filter (/operator/stations) */
          stationId?: string;
        };
      };
      responses: {
        /** returns currently active system alerts */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['systemAlert']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/operating-calendar': {
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** optional id of the station to use in the filter (/operator/stations) */
          stationId?: string;
        };
      };
      responses: {
        /** successful operation */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['systemCalendar']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/operating-hours': {
    /** Describes the hours of operation of all available systems of the transport operator [from GBFS] */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** optional id of the station to use in the filter (/operator/stations) */
          stationId?: string;
        };
      };
      responses: {
        /** successful operation */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['systemHours']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/information': {
    /** Describes the system including System operator, System location, year implemented, URLs, contact info, time zone. [from GBFS] */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
      };
      responses: {
        /** successful operation */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['systemInformation'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/pricing-plans': {
    /** Describes pricing of systems or assets [from GBFS] */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** optional id of the region to use in the filter (/operator/regions) */
          regionId?: string;
          /** optional id of the station to use in the filter (/operator/stations) */
          stationId?: string;
        };
      };
      responses: {
        /** returns standard pricing plans for an operator */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['systemPricingPlan']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/operator/regions': {
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
        };
      };
      responses: {
        /** successful operation */
        200: {
          content: {
            'application/json': Array<components['schemas']['systemRegion']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/payment/journal-entry': {
    /** Returns all the journal entries that should be paid per leg */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        query: {
          /** start of the selection */
          from?: string;
          /** end of the selection */
          to?: string;
          state?: components['schemas']['journalState'];
          id?: string;
          /** type of booking line (e.g. fare, addition costs, fines, ...) */
          category?:
            | 'ALL'
            | 'DAMAGE'
            | 'LOSS'
            | 'STOLEN'
            | 'EXTRA_USAGE'
            | 'REFUND'
            | 'FINE'
            | 'OTHER_ASSET_USED'
            | 'CREDIT'
            | 'VOUCHER'
            | 'DEPOSIT'
            | 'OTHER';
          /** start of the selection */
          offset?: number;
          /** count of the selection */
          limit?: number;
        };
      };
      responses: {
        /** journal entries */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['journalEntry']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/payment/{id}/claim-extra-costs': {
    /** extra costs that the TO has to charge to the MP or vice versa. */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        /** journal entry received, will be processed (state = INVOICED) */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['journalEntry'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['extraCosts'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/support/': {
    /** creates a request for support from end user via MP */
    post: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
      };
      responses: {
        /** support request acknowledged */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': components['schemas']['supportStatus'];
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
      requestBody: {
        content: {
          'application/json': components['schemas']['supportRequest'];
        };
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
  '/support/{id}/status': {
    /** Gets the status report of the support request. Last status (highest order number) is the current status */
    get: {
      parameters: {
        header: {
          /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
          'Accept-Language': components['parameters']['acceptLanguage'];
          /** API description, can be TOMP or maybe other (specific/derived) API definitions */
          Api: components['parameters']['api'];
          /** Version of the API. */
          'Api-Version': components['parameters']['apiVersion'];
          /** The ID of the sending maas operator */
          'maas-id': components['parameters']['maasId'];
          /** The ID of the maas operator that has to receive this message */
          'addressed-to'?: components['parameters']['addressedTo'];
        };
        path: {
          /** Booking identifier */
          id: string;
        };
      };
      responses: {
        /** support status delivered */
        200: {
          headers: {
            /** The language/localization of user-facing content */
            'Content-Language': string;
          };
          content: {
            'application/json': Array<components['schemas']['supportStatus']>;
          };
        };
        400: components['responses']['400BadRequest'];
        401: components['responses']['401Unauthorized'];
        403: components['responses']['403Forbidden'];
        404: components['responses']['404NotFound'];
      };
    };
    parameters: {
      header: {
        /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
        'Accept-Language': components['parameters']['acceptLanguage'];
        /** API description, can be TOMP or maybe other (specific/derived) API definitions */
        Api: components['parameters']['api'];
        /** Version of the API. */
        'Api-Version': components['parameters']['apiVersion'];
        /** The ID of the sending maas operator */
        'maas-id': components['parameters']['maasId'];
        /** The ID of the maas operator that has to receive this message */
        'addressed-to'?: components['parameters']['addressedTo'];
      };
    };
  };
}

export interface components {
  schemas: {
    /** street address, including number OR PO box number, eventually extended with internal reference like room number, could match Content-Language */
    address: {
      streetAddress: string;
      /** street, consistent with streetAddress */
      street?: string;
      /** house number, consistent with streetAddress */
      houseNumber?: number;
      /** the additional part of the house number (f.x. 13bis, where 'bis' is the additional part), consistent with streetAddress */
      houseNumberAddition?: string;
      /** additional information to find the address (f.x. just around the corner) */
      addressAdditionalInfo?: string;
      /** city or town, principal subdivision such as province, state or county, could match Content-Language */
      areaReference: string;
      /** specified city or town, consistent with areaReference */
      city?: string;
      /** province or region, consistent with areaReference */
      province?: string;
      /** state, consistent with areaReference */
      state?: string;
      postalCode?: string;
      country?: components['schemas']['country'];
    };
    amountOfMoney: {
      /** This should be in the base unit as defined by the ISO 4217 currency code with the appropriate number of decimal places and omitting the currency symbol. e.g. if the price is in US Dollars the price would be 9.95. This is inclusive VAT */
      amount?: number;
      amountExVat?: number;
      /** ISO 4217 currency code */
      currencyCode?: string;
      /** value added tax rate (percentage of amount) */
      vatRate?: number;
      vatCountryCode?: components['schemas']['country'];
    };
    asset: {
      /** Identifier of an asset. Whenever used in Operator Information changed after every trip (GDPR). */
      id: string;
      /** true indicates the bike is currently reserved for someone else */
      isReserved?: boolean;
      /** optional addition to determine if an asset is reserved in the future */
      isReservedFrom?: string;
      /** optional addition to determine when asset is available in the future */
      isReservedTo?: string;
      /** true indicates the asset is currently disabled (broken) */
      isDisabled?: boolean;
      /** deep-linking option from GBFS+. Only added to be consistent with GBFS 2.0 */
      rentalUrl?: string;
      /** deep-linking option from GBFS 2.0. Only added to be consistent with GBFS 2.0 */
      rentalUrlAndroid?: string;
      /** deep-linking option from GBFS 2.0. Only added to be consistent with GBFS 2.0 */
      rentalUrlIOS?: string;
      overriddenProperties: components['schemas']['assetProperties'];
    };
    /** These classes are taken from the NeTeX standard, but ALL and UNKNOWN are removed. On the other hand OTHER and PARKING are added. */
    assetClass:
      | 'AIR'
      | 'BUS'
      | 'TROLLEYBUS'
      | 'TRAM'
      | 'COACH'
      | 'RAIL'
      | 'INTERCITYRAIL'
      | 'URBANRAIL'
      | 'METRO'
      | 'WATER'
      | 'CABLEWAY'
      | 'FUNICULAR'
      | 'TAXI'
      | 'SELFDRIVE'
      | 'FOOT'
      | 'BICYCLE'
      | 'MOTORCYCLE'
      | 'CAR'
      | 'SHUTTLE'
      | 'OTHER'
      | 'PARKING'
      | 'MOPED'
      | 'STEP';
    assetType: {
      /** Unique identifier of an asset type, */
      id: string;
      /** If staionId is present, the nrAvailable is expected to find the availableity at that particular station */
      stationId?: string;
      nrAvailable?: number;
      assets?: Array<components['schemas']['asset']>;
      assetClass: components['schemas']['assetClass'];
      /** a more precise classification of the asset, like 'cargo bike', 'public bus', 'coach bus', 'office bus', 'water taxi',  'segway'. This is mandatory when using 'OTHER' as class. */
      assetSubClass?: string;
      sharedProperties: components['schemas']['assetProperties'];
    };
    /** what kind of asset is this? Classify it, give the aspects. Most aspects are optional and should be used when applicable. */
    assetProperties: {
      /** name of asset (type), required in either assetType or asset, should match Content-Language */
      name?: string;
      location?: components['schemas']['place'];
      fuel?:
        | 'NONE'
        | 'GASOLINE'
        | 'DIESEL'
        | 'ELECTRIC'
        | 'HYBRID_GASOLINE'
        | 'HYBRID_DIESEL'
        | 'HYBRID_GAS'
        | 'HYDROGEN'
        | 'GAS'
        | 'BIO_MASS'
        | 'KEROSINE'
        | 'OTHER';
      /** Energy efficiency */
      energyLabel?: 'A' | 'B' | 'C' | 'D' | 'E';
      co2PerKm?: number;
      /** brand of the asset */
      brand?: string;
      model?: string;
      buildingYear?: number;
      /** true indicates asset is allowed to travel abroad */
      travelAbroad?: boolean;
      /** true indicates airconditioning required */
      airConditioning?: boolean;
      /** true indicates cabrio required */
      cabrio?: boolean;
      /** colour of the asset, should match Content-Language */
      colour?: string;
      /** describes options to carry cargo, should match Content-Language */
      cargo?: string;
      /** describes if asset is or needs to be easily accessible */
      easyAccessibility?: 'LIFT' | 'ESCALATOR' | 'GROUND_LEVEL' | 'SIGHTIMPAIRMENT' | 'HEARINGIMPAIRMENT' | 'WHEELCHAIR';
      /** number of gears of the asset */
      gears?: number;
      /** type of gearbox */
      gearbox?: 'MANUAL' | 'AUTOMATIC' | 'SEMIAUTOMATIC';
      /** Link to an image of the asset */
      image?: string;
      /** true indicates infant seat required */
      infantSeat?: boolean;
      /** number of persons able to use the asset */
      persons?: number;
      /** true indicates pets are allowed on asset */
      pets?: boolean;
      /** way in which the asset is powered */
      propulsion?: 'MUSCLE' | 'ELECTRIC' | 'GASOLINE' | 'DIESEL' | 'HYBRID' | 'LPG' | 'HYDROGEN';
      /** true indicates smoking is allowed on asset */
      smoking?: boolean;
      /** percentage of charge available */
      stateOfCharge?: number;
      /** true indicates towing hook required */
      towingHook?: boolean;
      /** true indicates underground parking is allowed with asset */
      undergroundParking?: boolean;
      /** true indicates winter tires required */
      winterTires?: boolean;
      /** free text to describe asset, should match Content-Language */
      other?: string;
      /** this object can contain extra information about the type of asset. For instance values from the 'Woordenboek Reizigerskenmerken'. [https://github.com/efel85/TOMP-API/issues/17]. These values can also be used in the planning. */
      meta?: { [key: string]: any };
      /** access method for trip execution. Data will be delivered in the response of /booking/{id}/events - COMMIT or /leg/{id}/events - PREPARE (preferred). */
      accessMethods?: Array<components['schemas']['assetAccessMethods']>;
    };
    assetAccessMethods:
      | 'DEEPLINK'
      | 'QR'
      | 'AZTEC'
      | 'TOMP-API'
      | 'AXA-EKEY-OTP'
      | 'PHYSICAL-KEY'
      | 'BARCODE'
      | 'PDF'
      | 'HTML'
      | 'OVC'
      | 'EMV'
      | 'NONE';
    bankAccount: {
      /** account name */
      name?: string;
      /** account number */
      number?: string;
      country?: components['schemas']['country'];
      /** bank identification, like BIC code */
      bankIdentification?: string;
    };
    /** The booking information describing the state and details of an agreed upon trip */
    booking: components['schemas']['bookingRequest'] & {
      state?: components['schemas']['bookingState'];
      /** The legs of this booking, generally just one for simple legs, in order of how they will be travelled */
      legs: Array<components['schemas']['leg']>;
      /** The pricing information of the overall booking, in addition to any leg pricing, if not all legs have pricing the booking should have the fare */
      pricing?: components['schemas']['fare'];
      /** Arbitrary information that a TO can add */
      extraData?: { [key: string]: any };
    };
    /** operation on the bookingOption */
    bookingOperation: {
      operation: 'CANCEL' | 'EXPIRE' | 'DENY' | 'COMMIT';
      /** This operation can be done on behalf of another party. The MP can act on behalf of the END_USER (cancel this booking for me); to override the default origin. In case this field is missing, it must be assumed that the events the MP is sending, this field should contain "MP". And in case the TO is sending, "TO". */
      origin?: 'TO' | 'MP' | 'END_USER' | 'OTHER';
    };
    /** A booking requested by the MP */
    bookingRequest: {
      /** A unique identifier for the TO to know this booking by */
      id?: string;
      /** information about the origin, only to supply when requested in the conditionRequireBookingData */
      from?: components['schemas']['place'];
      /** The callback URL of the Maas Provider, to use as base url for callback, f.x. the POST legs/{id}/events and POST /bookings/{id}/events. Only to be provided when this deviates from standard or agreed URL. */
      callbackUrl?: string;
      /** information about the destination, only to supply when requested in the conditionRequireBookingData */
      to?: components['schemas']['place'];
      /** The user that wants to make this booking, only to supply when requested in the conditionRequireBookingData */
      customer?: components['schemas']['customer'];
    };
    /** The life-cycle state of the booking (from NEW to FINISHED) */
    bookingState:
      | 'NEW'
      | 'PENDING'
      | 'REJECTED'
      | 'RELEASED'
      | 'EXPIRED'
      | 'CONDITIONAL_CONFIRMED'
      | 'CONFIRMED'
      | 'CANCELLED'
      | 'STARTED'
      | 'FINISHED';
    /** Any kind of card that isn't a license, only provide the cards that are required */
    card: components['schemas']['cardType'] & {
      /** description of the card */
      cardDescription?: string;
      /** number of the card, like ID number, credit card or bank account number */
      cardNumber: string;
      /** additional number, like CVC code or IBAN code */
      cardAdditionalNumber?: string;
      validUntil: string;
      country?: components['schemas']['country'];
    };
    /** A generic description of a card, asset class and acceptors is only allowed for DISCOUNT/TRAVEL/OTHER cards */
    cardType: {
      /** The broad category of card */
      type: 'ID' | 'DISCOUNT' | 'TRAVEL' | 'BANK' | 'CREDIT' | 'PASSPORT' | 'OTHER';
      /** For use in case of OTHER. Can be used in bilateral agreements. */
      subType?: string;
      assetClass?: components['schemas']['assetClass'];
      /** references to accepting parties, only if applicable */
      acceptors?: string[];
    };
    condition: (
      | components['schemas']['conditionDeposit']
      | components['schemas']['conditionPayWhenFinished']
      | components['schemas']['conditionPostponedCommit']
      | components['schemas']['conditionRequireBookingData']
      | components['schemas']['conditionReturnArea']
      | components['schemas']['conditionUpfrontPayment']
    ) & {
      /** The specific subclass of condition, should match the schema name exactly */
      conditionType: string;
      /** An identifier for this condition that can be used to refer to this condition */
      id?: string;
    };
    /** in case the TO demands a deposit before usage. Requesting and refunding should be done using the /payment/claim-extra-costs endpoint. */
    conditionDeposit: components['schemas']['condition'] & components['schemas']['amountOfMoney'];
    /** in case the TO demands a direct payment after usage. */
    conditionPayWhenFinished: components['schemas']['condition'];
    conditionPostponedCommit: components['schemas']['condition'] & {
      ultimateResponseTime: string;
    };
    conditionRequireBookingData: components['schemas']['condition'] & {
      requiredFields: Array<
        | 'FROM_ADDRESS'
        | 'TO_ADDRESS'
        | 'BIRTHDATE'
        | 'EMAIL'
        | 'PERSONAL_ADDRESS'
        | 'PHONE_NUMBERS'
        | 'LICENSES'
        | 'BANK_CARDS'
        | 'DISCOUNT_CARDS'
        | 'TRAVEL_CARDS'
        | 'ID_CARDS'
        | 'CREDIT_CARDS'
        | 'NAME'
        | 'AGE'
      >;
    };
    /** a return area. In the condition list there can be multiple return area's. */
    conditionReturnArea: components['schemas']['condition'] & {
      /** station to which the asset should be returned */
      stationId?: string;
      /** area in which the asset should be returned as GeoJSON Polygon coordinates */
      returnArea?: components['schemas']['geojsonPolygon'];
      coordinates?: components['schemas']['coordinates'];
      /** the return hours of the facility (if different from operating-hours) */
      returnHours?: Array<components['schemas']['systemHours']>;
    };
    /** in case the TO demands a upfront payment before usage. The payment should be made in the booking phase. */
    conditionUpfrontPayment: components['schemas']['condition'];
    /** the TO can ask permission to do something to the MP, as the MP is financially responsible. */
    confirmationRequest: {
      type?: 'REPLACE_ASSET' | 'START_LEG';
      /** reference to the assetType in /operator/available-assets, this property can be set when replacing an asset (for another type). In case of a succesfull replacement, the /legs/{id}/events - ASSIGN_ASSET should be send to the MP to inform a change of asset has been made. */
      assetTypeId?: string;
    };
    /** a lon, lat (WGS84, EPSG:4326) */
    coordinates: {
      lng: number;
      lat: number;
    };
    /** two-letter country codes according to ISO 3166-1 */
    country: string;
    /** A MaaS user that wishes to make a booking, only use the fields required by booking conditions */
    customer: components['schemas']['traveler'] & {
      /** The identifier MaaS uses to identify the customer */
      id: string;
      /** optional reference field to the travelers in the planning request. */
      travelerReference?: string;
      initials?: string;
      /** First name of the customer */
      firstName?: string;
      /** Last name of the customer */
      lastName?: string;
      /** Middle name of the customer */
      middleName?: string;
      /** prefix of the customer, like titles */
      prefix?: string;
      /** postfix of the customer, like titles */
      postfix?: string;
      phones?: Array<components['schemas']['phone']>;
      /** the email address of the customer */
      email?: string;
      birthDate?: string;
      address?: components['schemas']['address'];
      /** base64 encoded */
      photo?: string;
      cards?: Array<components['schemas']['card']>;
      licenses?: Array<components['schemas']['license']>;
    };
    day: 'MON' | 'TUE' | 'WED' | 'THU' | 'FRI' | 'SAT' | 'SUN';
    /** The estimated distance travelled in the leg (in meters) */
    distance: number;
    /** A duration of some time (relative to a time) in milliseconds */
    duration: number;
    /** a formal description of an endpoint. */
    endpoint: {
      method: 'POST' | 'PUT' | 'GET' | 'DELETE' | 'PATCH';
      /** the exact path of the endpoint, starting after the base URL */
      path: string;
      /** in case the path is ending in /events, the event type/operator enum should be added here. */
      eventType?:
        | 'PREPARE'
        | 'ASSIGN_ASSET'
        | 'SET_IN_USE'
        | 'PAUSE'
        | 'START_FINISHING'
        | 'FINISH'
        | 'ISSUE'
        | 'CANCEL'
        | 'EXPIRE'
        | 'DENY'
        | 'COMMIT';
      status: 'NOT_IMPLEMENTED' | 'DIALECT' | 'IMPLEMENTED';
      /** does this endpoint support paging? In that case this endpoint can be accessed using query parameters offset=x and limit=y. Only allowed at endpoints that have specified these query parameters. */
      supportsPaging?: boolean;
      /** the maximum size of the pages (only valid when supportsPaging=true). If the limit-parameter of the request is above this amount, a http code 400 will be returned. */
      maxPageSize?: number;
    };
    /** a complete endpoint description, containing all endpoints, their status, but also the served scenarios and implemented process flows. The identifiers for the process flows can be found at https://github.com/TOMP-WG/TOMP-API/wiki/ProcessIdentifiers */
    endpointImplementation: {
      version: string;
      baseUrl: string;
      endpoints: Array<components['schemas']['endpoint']>;
      scenarios: Array<components['schemas']['scenario']>;
      processIdentifiers: components['schemas']['processIdentifiers'];
    };
    /** An error that the service may send, e.g. in case of invalid input, missing authorization or internal service error. See https://github.com/TOMP-WG/TOMP-API/wiki/Error-handling-in-TOMP for further explanation of error code. */
    error: {
      /** The TOMP specific error code. See https://github.com/TOMP-WG/TOMP-API/wiki/Error-handling-in-TOMP for more details of this error. */
      errorcode?: number;
      /** The category of this type of error. */
      type?: string;
      /** A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to occurrence of the problem, except to match Content-Language */
      title?: string;
      /** The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
      status?: number;
      /** A human-readable explanation specific to this occurrence of the problem, could match Content-Language */
      detail?: string;
      /** A URI reference that identifies the specific occurrence of the problem.  It may or may not yield further information if dereferenced. */
      instance?: string;
    };
    /** Costs that the TO is charging the MP; credits are negative. Other amounts should be positive */
    extraCosts: components['schemas']['amountOfMoney'] &
      ({
        category: components['schemas']['journalCategory'];
        /** free text to describe the extra costs. Mandatory in case of 'OTHER', should match Content-Language */
        description: string;
        /** e.g. number of litres, number of kilowatthour, etc */
        number?: number;
        numberType?: 'LITER' | 'KILOWATTHOUR' | 'CO2_COMPENSATION' | 'OTHER';
        account?: components['schemas']['bankAccount'];
        /** Arbitrary metadata that a TO can add, like voucher codes */
        meta?: { [key: string]: any };
      } & {
        amount: unknown;
      });
    /** the total fare is the sum of all parts, except for the 'MAX' farePart. This one descripes the maximum price for the complete leg. */
    fare: {
      /** is this fare an estimation? */
      estimated: boolean;
      /** user friendly description of the fare (e.g. 'full fare'), should match Content-Language */
      description?: string;
      /** in the future we'll set up an enumeration of possible "fare classes". For now it's free format. */
      class?: string;
      parts: Array<components['schemas']['farePart']>;
    };
    /** this describes a part of the fare (or discount). It contains a for instance the startup costs (fixed) or the flex part (e.g. 1.25 EUR per 2.0 MILES). The amount is tax included. In case of discounts, the values are negative. With 'MAX' you can specify e.g. a maximum of 15 euro per day. Percentage is mainly added for discounts. The `scale` properties create the ability to communicate scales (e.g. the first 4 kilometers you've to pay EUR 0.35 per kilometer, the kilometers 4 until 8 EUR 0.50 and above it EUR 0.80 per kilometer). */
    farePart: components['schemas']['amountOfMoney'] &
      ({
        /** type of fare part */
        type: 'FIXED' | 'FLEX' | 'MAX';
        /** in case of 'FLEX' mandatory. E.g. 0.5 EUR per HOUR */
        unitType?: 'KM' | 'SECOND' | 'MINUTE' | 'HOUR' | 'MILE' | 'PERCENTAGE';
        /** the number of km, seconds etc in the `per` part. In the first example of the description this should be 2.0 */
        units?: number;
        scaleFrom?: number;
        scaleTo?: number;
        scaleType?: 'KM' | 'MILE' | 'HOUR' | 'MINUTE';
        name?: string;
        class?: string;
        meta?: { [key: string]: any };
      } & {
        vatRate: unknown;
        amount: unknown;
      });
    /** An array  of WGS84 coordinate pairs */
    geojsonLine: Array<components['schemas']['geojsonPoint']>;
    /** Geojson Coordinate */
    geojsonPoint: number[];
    /** geojson representation of a polygon. First and last point must be equal. See also https://geojson.org/geojson-spec.html#polygon and example https://geojson.org/geojson-spec.html#id4. The order should be lon, lat [[[lon1, lat1], [lon2,lat2], [lon3,lat3], [lon1,lat1]]], the first point should match the last point. */
    geojsonPolygon: Array<components['schemas']['geojsonLine']>;
    journalEntry: components['schemas']['amountOfMoney'] & {
      /** id of the entry, leg id can be reused */
      journalId?: string;
      /** sequence id of the entry, in combination with journalId unique from TO perspective. */
      journalSequenceId?: string;
      /** the number of the invoice. Should be filled in when invoiced. */
      invoiceId?: string;
      invoiceDate?: string;
      state?: components['schemas']['journalState'];
      expirationDate?: string;
      comment?: string;
      /** the travelled distance. Only if applicable. */
      distance?: number;
      distanceType?: 'KM' | 'MILE';
      /** the time in seconds that the assed is used. Only if applicable. */
      usedTime?: number;
      bankAccount?: components['schemas']['bankAccount'];
      /** the specification of the amount; how is it composed. */
      details?: components['schemas']['fare'] | components['schemas']['extraCosts'];
    };
    journalState: 'TO_INVOICE' | 'INVOICED';
    journalCategory:
      | 'ALL'
      | 'DAMAGE'
      | 'LOSS'
      | 'STOLEN'
      | 'EXTRA_USAGE'
      | 'REFUND'
      | 'FINE'
      | 'OTHER_ASSET_USED'
      | 'CREDIT'
      | 'VOUCHER'
      | 'DEPOSIT'
      | 'OTHER';
    /** A planned (segment of) a booked trip using one asset type */
    leg: {
      /** The unique identifier (TO) of this leg */
      id?: string;
      /** The departure location of this leg, using this asset type */
      from: components['schemas']['place'];
      /** The destination of this leg, using this asset type */
      to?: components['schemas']['place'];
      /** The departure time of this leg */
      departureTime?: string;
      /** The intended arrival time at the to place */
      arrivalTime?: string;
      /** reference to the travelers field of the request. If missing, it is refering to the first (if any). it is an array to facilitate multiple users on one leg (e.g. using a car). If multiple access informations are needed, please create a leg per used asset. */
      travelerReferenceNumbers?: string[];
      /** The asset type used in this leg as determined during booking */
      assetType: components['schemas']['assetType'];
      /** The order of the leg in the booking. There can be multiple legs with the same sequence (different user or parallel usage (eg. parking lot and a bike)). */
      legSequenceNumber?: number;
      /** The concrete asset used for the execution of the leg */
      asset?: components['schemas']['asset'];
      /** The leg-specific pricing information, all fares are additive, if the booking does not have pricing set all legs should */
      pricing?: components['schemas']['fare'];
      suboperator?: components['schemas']['suboperator'];
      /** The conditions that apply to this leg, there may be more conditions in a parent booking and planning object (if this is returned as part of those) */
      conditions?: Array<components['schemas']['condition']>;
      state?: components['schemas']['legState'];
      departureDelay?: components['schemas']['duration'];
      arrivalDelay?: components['schemas']['duration'];
      distance?: components['schemas']['distance'];
      /** A list of coordinates describing the progress so far along the leg, as GeoJSON LineString coordinates */
      progressGeometry?: components['schemas']['geojsonLine'];
      /** The MaaS user's proof of their right to travel on this leg */
      ticket?: components['schemas']['token'];
      /** Data to open a specific asset (e.g. QR code, image base64) */
      assetAccessData?: components['schemas']['token'];
      /** Array of data to open a specific asset (e.g. QR code, image base64) */
      allAssetAccessData?: components['schemas']['tokenArray'];
    };
    /** event for the execution */
    legEvent: {
      time: string;
      event: 'PREPARE' | 'ASSIGN_ASSET' | 'SET_IN_USE' | 'PAUSE' | 'START_FINISHING' | 'FINISH' | 'TIME_EXTEND' | 'TIME_POSTPONE' | 'CANCEL';
      /** free text, should match Content-Language */
      comment?: string;
      /** urls to support the event e.g. pictures justifying the exit conditions */
      url?: string[];
      asset?: components['schemas']['asset'];
    };
    /** provides current asset location & duration and distance of the current leg */
    legProgress: {
      coordinates: components['schemas']['coordinates'];
      duration?: components['schemas']['duration'];
      distance?: components['schemas']['distance'];
    };
    /** status of a leg */
    legState: 'NOT_STARTED' | 'PREPARING' | 'IN_USE' | 'PAUSED' | 'FINISHING' | 'FINISHED' | 'ISSUE_REPORTED' | 'CANCELLED';
    /** driver or usage license for a specific user. Contains the number and the assetType you're allowed to operate (e.g. driver license for CAR) */
    license: components['schemas']['licenseType'] & {
      number?: string;
      /** in most countries a driver license has also a code. As TO you can exactly verify, based on this code if the license allows to operate it's assets, if the assetType too generic. */
      licenseCode?: string;
      validUntil?: string;
    };
    /** A category of license to use a certain asset class */
    licenseType: {
      assetClass: components['schemas']['assetClass'];
      issuingCountry?: components['schemas']['country'];
    };
    /** notifies the MaaS operator of issues with a booking [addendum] */
    notification: {
      type: 'VEHICLE_NOT_AVAILABLE' | 'USER_NO_SHOW' | 'ETA' | 'MESSAGE_TO_DRIVER' | 'MESSAGE_TO_END_USER' | 'OTHER';
      /** in case of ETA, the number of minutes until arrival at the pickup location */
      minutes?: number;
      /** free text, should match Content-Language */
      comment?: string;
    };
    phone: {
      /** only one phone in this array can have a true in this property */
      preferred?: boolean;
      /** phone number. In case of international usage, always provide the country code. */
      number?: string;
      kind?: 'LANDLINE' | 'MOBILE';
      type?: 'PRIVATE' | 'BUSINESS' | 'OTHER';
    };
    /** a origin or destination of a leg, non 3D. lon/lat in WGS84. */
    place: {
      /** Human readable name of the place, could match Content-Language */
      name?: string;
      stopReference?: Array<components['schemas']['stopReference']>;
      /** reference to /operator/stations */
      stationId?: string;
      coordinates: components['schemas']['coordinates'];
      physicalAddress?: components['schemas']['address'];
      extraInfo?: { [key: string]: any };
    };
    /** A travel planning for which bookable options are requested */
    planningRequest: {
      from: components['schemas']['place'];
      /** Maximum distance in meters a user wants to travel to reach the travel option */
      radius?: number;
      to?: components['schemas']['place'];
      /** The intended departure time. If left out and no arrivalTime is set, the current time should be assumed. */
      departureTime?: string;
      /** The intended arrival time, at the to place if set otherwise the time the user intends to stop using the asset. */
      arrivalTime?: string;
      /** The number of people that intend to travel, including the customer. */
      nrOfTravelers: number;
      /** Extra information about the people that intend to travel if relevant, length must be less than or equal to nrOftravelers. */
      travelers?: Array<components['schemas']['traveler']>;
      /** The specific asset(s) the user wishes to receive leg options for */
      useAssets?: string[];
      /** Id(s) of user groups that the user belongs to. This provides access to exclusive assets that are hidden to the public. Id's are agreed upon by TO and MP. */
      userGroups?: string[];
      /** The specific asset type(s) the user wishes to receive leg options for */
      useAssetTypes?: string[];
    };
    /** A travel planning with bookable options that fulfil the constraints of the planning */
    planning: {
      /** The time until which the presented options are (likely) available */
      validUntil: string;
      options: Array<components['schemas']['booking']>;
    };
    processIdentifiers: {
      operatorInformation: string[];
      planning: string[];
      booking: string[];
      tripExecution: string[];
      support: string[];
      payment: string[];
      general: string[];
    };
    requirement: {
      /** references to the first column of the specification */
      category: 'HR' | 'AV' | 'HV' | 'AB' | 'AER' | 'K' | 'ZR' | 'RR';
      /** references to the second column of the specification */
      number: string;
      /** conditionally extra information, referencing to the 3th column */
      type?: string;
      /** extra field for detailed information, not standardized */
      memo?: string;
      /** in some requirements there is references to '[variable number]' e.g. of meters (like ZR06) */
      'variable-number'?: number;
      /** days of week that are applicable */
      'applicable-days'?: Array<'MO' | 'TU' | 'WE' | 'TH' | 'FR' | 'SA' | 'SU'>;
    };
    /** Requirements the users has ((dis)abilities, share [TRUE|FALSE], preferences [TBD]). See also 'https://github.com/TOMP-WG/TOMP-API/blob/master/documents/Woordenboek%20Reizigerskenmerken%20CROW.pdf' */
    requirements: {
      abilities?: Array<components['schemas']['requirement']>;
    } & { [key: string]: any };
    scenario: 'POSTPONED_COMMIT' | 'DEPOSIT' | 'PAY_WHEN_FINISHED' | 'REQUIRE_BOOKING_DATA' | 'RETURN_AREA' | 'UPFRONT_PAYMENT';
    stationInformation: {
      /** unique identifier of a station */
      stationId: string;
      /** public name of the station, could match Content-Language */
      name: string;
      coordinates: components['schemas']['coordinates'];
      physicalAddress?: components['schemas']['address'];
      /** Cross street of where the station is located. This field is intended to be a descriptive field for human consumption. In cities, this would be a cross street, but could also be a description of a location in a park, etc, should match Content-Language */
      crossStreet?: string;
      /** ID of the region where the station operates (see "systemRegions") */
      regionId?: string;
      /** Array of enumerables containing the payment methods accepted at this station. */
      rentalMethods?: Array<'KEY' | 'CREDITCARD' | 'PAYPASS' | 'APPLEPAY' | 'ANDROIDPAY' | 'TRANSITCARD' | 'ACCOUNTNUMBER' | 'PHONE' | 'OTHER'>;
      /** web uri for renting assets at this station. Only added to be consistent with GBFS 2.0. */
      rentalUrl?: string;
      /** android uri for renting assets at this station. Only added to be consistent with GBFS 2.0. */
      rentalUrlAndroid?: string;
      /** ios uri for renting assets at this station. Only added to be consistent with GBFS 2.0. */
      rentalUrlIOS?: string;
    };
    /** reference to a stop (can be nation specific). This can help to specific pinpoint a (bus) stop. Extra information about the stop is not supplied; you should find it elsewhere. */
    stopReference: {
      /** type of external reference (GTFS, CHB). */
      type: 'GTFS_STOP_ID' | 'GTFS_STOP_CODE' | 'GTFS_AREA_ID' | 'CHB_STOP_PLACE_CODE' | 'CHB_QUAY_CODE' | 'NS_CODE';
      /** this field should contain the complete ID. E.g. NL:S:13121110 or BE:S:79640040 */
      id: string;
      country: components['schemas']['country'];
    };
    /** The operator of a leg or asset, in case this is not the TO itself but should be shown to the user */
    suboperator: {
      /** Name of the operator, could match Content-Language */
      name: string;
      /** the maasId from the operator */
      maasId?: string;
      /** short description of the operator, should match Content-Language */
      description?: string;
      /** contact information, should match Content-Language */
      contact?: string;
    };
    /** request for support */
    supportRequest: {
      /** the booking id */
      id?: string;
      supportType?:
        | 'BROKEN_DOWN'
        | 'NOT_AT_LOCATION'
        | 'MISSING_AFTER_PAUSE'
        | 'NOT_CLEAN'
        | 'NOT_AVAILABLE'
        | 'UNABLE_TO_OPEN'
        | 'UNABLE_TO_CLOSE'
        | 'API_TECHNICAL'
        | 'API_FUNCTIONAL'
        | 'ACCIDENT'
        | 'OTHER';
      location?: components['schemas']['place'];
      time?: string;
      /** the priority of the support request. */
      priority?: 'ERROR_CANNOT_CONTINUE' | 'ERROR_CAN_CONTINUE' | 'DISTURBING_ISSUE' | 'QUESTION' | 'OTHER';
      /** contact information of the end user in case of direct response requests, like phone number */
      contactInformationEndUser?: string;
      comment?: string;
      /** time to respond in minutes. */
      requestedResponseTime?: number;
    };
    /** the current status of support */
    supportStatus: components['schemas']['supportRequest'] & {
      status?: 'PROCESSING' | 'UPDATE_REQUESTED' | 'RESOLVED' | 'CANCELLED';
      /** time in minutes to expected resolution of support request */
      timeToResolution?: number;
      /** the sequence number of status of the support issue */
      order?: number;
      /** free text to send to the end user. */
      comment?: string;
    };
    systemAlert: {
      /** a unique identifier for this alert */
      alertId: string;
      alertType: 'SYSTEM_CLOSURE' | 'STATION_CLOSURE' | 'STATION_MOVE' | 'OTHER';
      /** Array of hashes with the keys "start" and "end" indicating when the alert is in effect (e.g. when the system or station is actually closed, or when it is scheduled to be moved). If this array is omitted then the alert should be displayed as long as it is in the feed. */
      startAndEndTimes?: string[][];
      /** Array of strings - If this is an alert that affects one or more stations, include their ids, otherwise omit this field. If both stationIDs and regionIDs are omitted, assume this alert affects the entire system */
      stationIds?: string[];
      /** Array of strings - If this system has regions, and if this alert only affects certain regions, include their ids, otherwise, omit this field. If both stationIDs and regionIDs are omitted, assume this alert affects the entire system */
      regionId?: string[];
      /** URL where the customer can learn more information about this alert, if there is one */
      url?: string;
      /** A short summary of this alert to be displayed to the customer, should match Content-Language */
      summary: string;
      /** Detailed text description of the alert, should match Content-Language */
      description?: string;
      lastUpdated?: string;
    };
    systemCalendar: {
      /** If this parameter is present, it means that start and end prameters correspond to the opening and closing days of the station. (GET /operator/stations) */
      stationId?: string;
      /** If this parameter is present, it means that start and end prameters correspond to the opening and closing days for the region. (GET /operator/regions) */
      regionId?: string;
      /** Starting month for the system operations (1-12) */
      startMonth: number;
      /** Starting day for the system operations (1-31) */
      startDay: number;
      /** Starting year for the system operations */
      startYear?: number;
      /** Ending month for the system operations (1-12) */
      endMonth: number;
      /** Ending day for the system operations (1-31) */
      endDay: number;
      /** Ending year for the system operations */
      endYear?: number;
    };
    systemHours: {
      /** This indicates that this set of rental hours applies to either members or non-members only. */
      userType?: 'MEMBER' | 'NON_MEMBERS';
      /** If this parameter is present, it means that startTime and endTime correspond to the opening and closing hours of the station. (GET /operator/stations) */
      stationId?: string;
      /** If this parameter is present, it means that startTime and endTime correspond to the opening and closing hours for the region. (GET /operator/regions) */
      regionId?: string;
      startTime: string;
      endTime: string;
      /** An array of abbreviations (first 3 letters) of English names of the days of the week that this hour object applies to (i.e. ["mon", "tue"]). Each day can only appear once within all of the hours objects in this feed. */
      days: Array<components['schemas']['day']>;
    };
    systemInformation: {
      /** identifier for this transport system. This should be globally unique (even between different systems) */
      systemId: string;
      /** The languages supported by this operator for user-facing text. These can be requested using the Accept-Language header and should then be returned in Content-Language */
      language: string[];
      /** Full name of the system to be displayed to customers, could match Content-Language */
      name: string;
      /** Optional abbreviation for a system */
      shortName?: string;
      /** Name of the operator of the system, could match Content-Language */
      operator?: string;
      /** The URL of the transport operator. The value must be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. */
      url?: string;
      /** A fully qualified URL where a customer can purchase a membership or learn more about purchasing memberships */
      purchaseUrl?: string;
      /** Uri to detect if the app is available at the mobile. */
      discoveryUriAndroid?: string;
      /** Uri to detect if the app is available at the mobile. */
      discoveryUriIOS?: string;
      /** Uri to the app in the store. */
      storeUriAndroid?: string;
      /** Uri to the app in the store. */
      storeUriIOS?: string;
      startDate?: string;
      /** A single voice telephone number for the specified system. This field is a string value that presents the telephone number as typical for the system's service area. It can and should contain punctuation marks to group the digits of the number. */
      phoneNumber?: string;
      /** A single contact email address for customers to address questions about the system */
      email?: string;
      /** A single contact email address for consumers of this feed to report technical issues. */
      feedContactEmail?: string;
      /** The time zone where the system is located. Time zone names never contain the space character but may contain an underscore. Please refer to the "TZ" value in https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for a list of valid values */
      timezone: string;
      /** A fully qualified URL of a page that defines the license terms for the GBFS data for this system, as well as any other license terms the system would like to define (including the use of corporate trademarks, etc) */
      licenseUrl?: string;
      /** Describes the type of system */
      typeOfSystem: 'FREE_FLOATING' | 'STATION_BASED' | 'VIRTUAL_STATION_BASED';
      chamberOfCommerceInfo?: components['schemas']['chamberOfCommerceInfo'];
      /** Added to include possibility to communicatie general rental conditions like minimum age, max. reservation time etc. [amended] */
      conditions?: string;
      /** the type of product offered. SHARING should also be used for public transport. */
      productType?: 'RENTAL' | 'SHARING' | 'PARKING' | 'CHARGING';
      assetClasses?: Array<components['schemas']['assetClass']>;
    };
    systemPricingPlan: {
      /** a unique identifier for this plan in the system */
      planId: string;
      /** a fully qualified URL where the customer can learn more about this particular scheme */
      url?: string;
      /** name of this pricing scheme, could match Content-Language */
      name: string;
      /** pricing plan for a specific station */
      stationId?: string;
      /** pricing plan for a specific region */
      regionId?: string;
      fare: components['schemas']['fare'];
      /** false indicates that no additional tax will be added (either because tax is not charged, or because it is included) true indicates that tax will be added to the base price */
      isTaxable: boolean;
      /** Text field describing the particular pricing plan in human readable terms. This should include the duration, price, conditions, etc. that the publisher would like users to see. This is intended to be a human-readable description and should not be used for automatic calculations, should match Content-Language */
      description: string;
    };
    systemRegion: {
      /** Unique identifier for this region */
      regionId: string;
      /** Public name for this region, could match Content-Language */
      name: string;
      /** The area served by the region (i.e. where one may travel using the service's assets) as GeoJSON Polygon coordinates */
      serviceArea?: components['schemas']['geojsonPolygon'];
    };
    /** The validity token (such as booking ID, travel ticket etc.) that MaaS clients will display to show their right to travel, or use to access an asset */
    token: {
      validFrom: string;
      validUntil: string;
      /** The type of data held in this token, will later be an enum */
      tokenType: string;
      tokenData?: components['schemas']['tokenData'];
    };
    tokenArray: Array<components['schemas']['token']>;
    tokenData: {
      tokenType: string;
    } & { [key: string]: any };
    /** Arbitrary data the TO may pass along the ticket to the client */
    tokenDefault: components['schemas']['tokenData'];
    /** deeplink info */
    tokenDeeplink: components['schemas']['tokenData'] & {
      /** the base deeplink url for the MP app. Can be extended by the 'knownParamaters'. Including the scheme. */
      url?: string;
      knownParameters?: string[];
    };
    /** Axa EKey information */
    tokenEKey: components['schemas']['tokenData'] & {
      ekey: {
        /** certificate */
        key?: string;
        /** one time pass key */
        passkey?: string;
      };
      lock: {
        /** physical address */
        bdAddress?: string;
        /** how it advertises itself */
        deviceName?: string;
      };
    };
    /** QR information */
    tokenQR: components['schemas']['tokenData'] & {
      /** base 64 QR code */
      base64: string;
      version?: string;
    };
    /** To identify the operator */
    chamberOfCommerceInfo: {
      number?: string;
      place?: string;
    };
    /** A generic description of a traveler, not including any identifying information */
    traveler: {
      /** Whether this traveler's identity and properties have been verified by the MaaS provider */
      isValidated?: boolean;
      /** Age of the traveler, may be approximate */
      age?: number;
      /** reference number of the traveler. This number could be used to refer to in the planning result. */
      referenceNumber?: string;
      /** The kind of cards this traveler possesses */
      cardTypes?: Array<components['schemas']['cardType']>;
      /** The kind of licenses this traveler possesses */
      licenseTypes?: Array<components['schemas']['licenseType']>;
      requirements?: components['schemas']['requirements'];
      /** identifier for this traveler in the personal data store. This identifier can be used to get personal information from the provider specified in the "knownIdentifierProvider" */
      knownIdentifier?: string;
      /** provider for personal information. Can be a URI or identifier. */
      knownIdentifierProvider?: string;
    };
  };
  responses: {
    /** Request was successfully accepted for processing but has not yet completed. */
    '202Accepted': unknown;
    /** Request was successful, no content to return. */
    '204NoContent': unknown;
    /** Bad request. See https://github.com/TOMP-WG/TOMP-API/wiki/Error-handling-in-TOMP for further explanation of error code. */
    '400BadRequest': {
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response. */
    '401Unauthorized': {
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server. */
    '403Forbidden': {
      content: {
        'application/json': components['schemas']['error'];
      };
    };
    /** The requested resources does not exist or the requester is not authorized to see it or know it exists. */
    '404NotFound': unknown;
    /** The request will not be fulfilled. The request itself is legal, but the content conflicts with the server and might be stale. The user might try again after looking up the current state of the resource. */
    '409Conflict': unknown;
    /** The requested resource is no longer available. This is permanent. */
    '410Gone': unknown;
  };
  parameters: {
    /** A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information */
    acceptLanguage: string;
    /** API description, can be TOMP or maybe other (specific/derived) API definitions */
    api: string;
    /** Version of the API. */
    apiVersion: string;
    /** The ID of the sending maas operator */
    maasId: string;
    /** The ID of the maas operator that has to receive this message */
    addressedTo: string;
  };
}

export interface operations {}

export interface external {}
